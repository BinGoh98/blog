---
title: "谈一谈TCP连接"
date: 2020-11-10T17:01:34+08:00
draft: false
toc: true
author: "彬Goh"
keywords: ["TCP连接","三次握手","四次挥手"]
description: "谈一谈TCP连接"
tags: ["TCP","python"]
categories: ["计算机网络"]
mathjax: true
mathjaxEnableSingleDollar: true
---
<!--more-->

# 套接字编程

# 什么是套接字

在因特网中，我们用`IP地址`区分不同的主机。而一个主机上往往运行着多个进程，比如qq和微信。我们使用qq发出去的消息，必然是希望对方用qq接收到。那么如何区分一个主机上的不同进程呢？答案是`端口号(Port)`。`端口号`是一个16比特的数，其大小在`0~65535`之间。其中`0~1023`范围的端口号是受限制的，被特定的应用层协议使用，比如`http`和`ftp`。客户端可以选择剩余的端口号来使用。

当一个新的应用程序（有网络通信的）开发完之后，必须为其分配一个端口号。这样，`IP:Port`就可以唯一标识一个主机上的应用程序，并用这个标识进行通信。<u>我们称`IP:Port`为套接字。</u>

## python实例

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6tns1y8j30da0dnwex.jpg)  

客户端-服务端请求应答模型如上图所示。

### 服务端

```python
from socket import *
serverPort = 8090
serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind(('', serverPort))
serverSocket.listen(1)
print('The server is ready to recieve!')
while True:
    try:
        connectionSocket, addr = serverSocket.accept()
        msg = connectionSocket.recv(1024).decode()
        ack = "Get your: " + msg.upper() # 将客户端消息转为大写
        connectionSocket.send(ack.encode())
        connectionSocket.close()
    except KeyboardInterrupt:
        break
    
serverSocket.close()
```

1. 首先使用`socket`创建一个TCP嵌套字，其中`SOCK_STREAM`用于指示这是一个TCP连接而非UDP连接；
2. `bind`绑定主机名和端口号；
3. `listen`令服务器监听`8090`端口来自客户端的TCP连接请求。其中的参数`1`表示请求的最大连接数为1；
4. 最后在`while`循环中，使用`accept()`方法。接收到来自客户端的请求之后会重新分配一个名为`connectionSocket`的新的套接字，给这个特定的用户使用。这样可以让一个套接字专门用来接收请求，生成的连接套接字用于不同客户端的通信，防止欢迎套接字被一个请求占用之后，其他请求无法再响应了。

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6uepevyj30ki0ke1hc.jpg" alt="image-20201109160840609" style="zoom:50%;" />

> 其中的`try`和`except`可以先不用管，这个是为了中断程序时可以自动释放端口号。

### 客户端

```python
from socket import *

serverName = '127.0.0.1'
serverPort = 8090
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, serverPort))
msg = "hello world!"
clientSocket.send(msg.encode()) # 发送
response = clientSocket.recv(1024).decode() # 接受响应
print('Data from server ==>', response)
clientSocket.close()
```

1. 首先使用`socket`创建一个TCP嵌套字，与服务端一样；
2. `connect`与服务端建立连接，发生了三次握手的过程；

### 运行程序

```python
# server
The server is ready to recieve!
```

```python
# client
Data from server ==> Get your: HELLO WORLD!
```

## wireshark抓包

尝试用`wireshark`抓包看一下我们程序运行的过程。

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk6zoh8wdj32800la10t.jpg" alt="截屏2020-11-09 下午4.23.42" style="zoom:50%;"/>

1. 客户端默认工作在`51171`端口，服务端监听`8090`端口。`1～3`是三次握手的过程，`8/10/11/12`是四次挥手的过程。中间是数据传输与应答过程。

2. 第5个包中，客户端发送了`hello world!`；第6个包是服务端发送`ACK`；第7个包是服务端发送`Data from server ==> Get your: HELLO WORLD!`；第9个包是客户端发送的`ACK`；

从抓包过程中我们可以看出，仅仅是简单地传输两个字符串，就需要这个多次`TCP`包的传输。这些传输到底是什么含义呢？

# 连接与可靠

众所周知，`TCP`是面向连接的可靠的传输协议。

- 面向连接指的是在传输实体数据之前必须建立连接：上面的`connect`就是建立连接的过程；
- 可靠即能保证接收到的数据是发送方想发送的数据。

为什么会发生不可靠的传输呢？主要有两种情况，一种是比特差错；另一种是丢包。

## 比特差错

根据香农理论，当通过信道的信号速率超过某个值时，信号的误码率会显著提高，也就是比特差错数会显著提高。同时由于噪声的影响也会使得接收到判断发送端发送的是1还是0的时候发生错误。

## 丢包

从北京往上海发一个包，中间会经过路由器和交换机中转。大多数分组交换剂在输入端使用**存储转发传输**：<u>也就是将整个包都接受完了之后，才会向输出链路传输该分组。</u>分组交换机的每条链路具有一个输出缓存，用于存储准备发往该链路的分组。由于发送速率是有限的，所以如果包到达的速率要大于发送的速率的话，就必须在这个缓存区等待。而缓存区大小往往是有限的，所以超过的部分可能会被丢弃，从而发送**丢包**！

还有一种是当发包的速度过快了，服务器应用程序没来得及消费这些东西，而缓存区也满了，那么就会丢弃这些包。

# 如何保证可靠

## 比特差错

首先看一下TCP报文格式：  
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk70q2r44j30on0ew74h.jpg" alt="img" style="zoom:67%;" />


这里的`检验和`用于检验比特差错。目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。

**发送方**计算TCP的检验和的计算方法如下：

0. 将检验和字段设为0；

1. 添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号（一般为6）和16位的TCP总长度（这个长度是计算获得的，不是直接有的字段）。

2. 对所有16比特字求和，求和时遇到的任何溢出都将被<u>回卷</u>。

3. 对和进行反码运算。计算的结果填到检验和字段中。

> 回卷就是超过16bit的部分重新加到后16bit上。比如0x36666，回卷之后就是0x3 + 0x6666 = 0x6669。

**接收方**检验`checksum`的方式如下：

1. 添加12字节的伪头部，包括：源IP地址、目的IP地址、协议版本号和16位的TCP总长度。
2. 对所有16比特字求和，求和时遇到的任何溢出都将被<u>回卷</u>。
3. 判断结果是否为`0xFFFF`，如果不是则出错。

用`wireshark`抓包时可以发现，抓包之后的`checksum`都是错误的：`[Header checksum status: Unverified]`。手动进行求和验证发现也是无法通过的。这是为什么呢？

原来是因为为了减少CPU的开销，检验和的计算会交给硬件（网卡）而不是`TCP`来计算。而抓包时还没有到网卡这一层，所以系统会在`checksum`这里随机填一些数字，而不是真正的检验和。在windows电脑中可以关闭网卡检验和再尝试。（mac中我还没有找到设置的方法，求指导！）

<u>但是需要注意的是！检验和并不是只有TCP才有的，UDP和IP计算都会有这个步骤。</u>

## 丢包

客户端发了几个包过去，客户端和服务端如何能保证是不丢失的？保证不丢包的前提是，<u>如果发生了丢包，他们必须是能够知道的</u>，否则就没法进行重传。

很容易想到的一种方法是**应答**。

`Client`发送一个包之后，等待`Server`响应。例如`ACK=1`表示我收到了完整的包；`ACK=0`表示我收到了受损的包，请重发一次。如果`Client`在等待一定时常之后没有收到`Server`响应，就认为包是丢失的，开始重传。

这种方式有一些弊端：

1. 如何保证收到的`ACK`在途中不会因为噪声干扰发生变化；
2. 因为客户端都等待服务端的响应，所以在这个过程中无法发送其他包，效率是低下的。
3. 如果`Server`接收到的是完整的包，但是`ACK`在响应过程中丢失了，客户端会在一定时间之后重新发送一个包。服务端无法区别这个是重传的包还是新的包。

既然无法区分包，那不如就给所有包标上序号吧！这个就是TCP报文头中的`序号`和`确认号`。

由于TCP是一个全双工的协议，所以客户端和服务端都是可以相互发送报文的。序号用于表示自己这个报文的标号，而确认号表示我希望你能给我发哪个报文（间接表明了你发过来的报文有哪些是安全到达的）。

这是TCP报文首部中最重要的两个字段，需要好好理解一下！

### 序号与确认号

TCP把数据看成是一个无结构的、有序的字节流。序号并不是对报文进行编号，而是对字节流进行编号。

例如主机A的一个进程想通过TCP连接向主机B的一个进程发送一个数据流。这个数据流的大小是500 000字节，一个TCP报文能放的数据大小是1000个字节。那么这个数据流将被拆分成$500000/1000 = 500$个包，第一个报文分配序号`0`，第二个报文分配序号`1000`，以此类推。

主机A填充进报文的确认号是主机A希望从主机B收到的下一个字节的序号。例如主机A已经收到了`0~999`的所有字节，那么它下一个希望收到的序号是`1000`，则A发送的TCP包的确认号是`1000`。

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk71mhau1j30ms0p67wh.jpg" alt="截屏2020-11-10 下午1.52.18" style="zoom:50%;"/>  

这样发送方可以直接通过应答方发送的确认号就可以知道自己之前发送报文的确认情况。如果经过一定时间没有收到应答方的回答的话，就进行重传。由于重传时`Seq`是不变的，所以应答方可以通过它来判断是否是重复收到同一个报文了。

但一次只发一个报文终究是很费时的，所以会一次性传多个报文。虽然发送报文是按序的，但是由于网络链路的影响，接受报文可能不是有序的，甚至可能发生中间的丢包。那么怎么办呢？

- 退回N步
- 选择重传

### (1) 退回N步 Go-Back-N

可以直接在《计算机网络：自顶向下方法》的配套实验网站中看演示动画：

https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html

在GBN算法中，所有分组必须有序到达，否则会被丢弃。也就是接收方丢弃所有失序分组。而当发送方没有收到分组`n`的应答，但是却收到了`n+1, n+2`的应答时，在等一定时间之后，`n, n+1, n+2`都会被重发。

这种方法的优点是，在接受侧不需要缓存任何失序分组；发送侧需要维护一个发送窗口。

但是由于一些明明完整到达的报文，由于顺序不对会被丢弃，需要重发，这个会影响性能。尤其是当窗口长度和带宽时延都很大时，可能会需要大量重传分组。而很多分组其实没必要重传。

### (2) 选择重传

演示地址：
https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html

这里需要发送方和接收方都维护一个窗口。对于发送方来说，只有当窗口内连续的前`x`个包都收到了回应，才会把窗口推进`x`。一定时间之后如果还没收到，则重发。

### TCP的重传

TCP报文的重传结合了这两种方式。

1. 首先TCP确认是<u>累计式的，并不会对正确接受但是失序的报文逐个确认</u>。

   比如说发送了`1, 2, ... n, n+1,n+2`几个包，但是接收方只收到了`1, 2, ..., n+1,n+2`，接收方会反复回应`ACK=n`，而不会对之后接受的包进行回应。

2. 但是TCP提供了缓存机制。发送方接收到回应`ACK=n`之后只会重传`n`包，而不会重传之后的包。不过发送方不是收到一个`ACK=n`就会重发的，它会在收到3个冗余`ACK`之后才会执行快速重传。

   <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk73kz657j30jw0se4qp.jpg" alt="image-20201110150742521" style="zoom:50%;" />

3. 由于（1）的特性，所以TCP确认并不需要对`1, 2, ..., n-1`都进行，只要收到了`n`的确认，就可以认为之前的包都有序送达了！这样即便`ACK=100`丢失了，也不会有影响。

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk7489ai8j30iu0oq1kx.jpg" alt="image-20201110144849613" style="zoom:50%;" />
<center>RFC 5681 产生ACK的建议</center>

| 事件                                            | TCP接收方动作                                                |
| ----------------------------------------------- | ------------------------------------------------------------ |
| 1~n都到达并ACK了; 现在到了n+1                   | 延迟ACK。对n+2最多等待500ms，如果没到达则发送一个ACK确认n+1。 |
| 1~n-1都到达并确认了，n到达还没确认；现在到了n+1 | 立即发送单个累计ACK=n+2，同时确认n和n+1。                    |
| 1~n-1都到达并确认了，n没到达；现在到了n+1       | 立即发送冗余ACK=n                                            |
| 能部分或完全填充接受数据间隔的报文段到达        | 如果该报文段填的是对早的空的段，立即发送ACK                  |

## 连接与断开的过程

上述是建立完TCP连接之后报文的传输过程。TCP中另一个很重要的是<u>建立连接与断开连接</u>的过程。其实这个本质和普通的报文传输是一样的，只不过会用一些特殊的位来表示我们正在建立/断开连接。

### 三次握手🤝建立连接

1. 客户端的TCP先向服务器端的TCP发送一个特殊的TCP报文段，该报文段不包含应用层数据，但是将报文段的首部`SYN`位设置为`1`。另外客户端会随机选择生成一个`client_isn`放入起始的TCP序号中。

2. 服务器主机收到包含`SYN=1`的报文段之后，就知道有客户端想要建立连接了。所以服务器会为该TCP连接分配TCP缓存和变量。然后返回一个响应，表示允许建立连接。这个允许连接的报文也不包含应用层数据，但是有`SYN=1`，`序号=server_isn`，`确认号=client_isn+1`，`ACK=1`。（这里虽然没有应用层的数据，但由于它是建立连接的报文，所以确认号是在接收的序号上+1的，这点和单纯的数据传输不太一样）

3. 客户端接收到服务器的响应之后，客户端也为该连接分配缓存和变量。然后客户端向服务端发送另一个报文：`SYN=0`，`序号=client_isn+1`，`确认号=server_isn+1`。<u>在这个阶段，可以在报文段负载中携带客户端到服务器的数据了！</u>

4. 之后通信的所有报文段`SYN=0`。

   <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk74tbkvwj30o20nk4qp.jpg" alt="image-20201110161231022" style="zoom:50%;" />

> 实际上在第二步中，服务器并不会直接为这个TCP连接分配缓存，因为有可能会有黑客不断发送第一步的连接请求，但是不发送第三步的报文，这样会导致服务器建立了大量TCP缓存，但是却都没有用！这个被称为**SYN攻击**！

- [x] 为何要3次握手？

1. 确认客户端和服务端都有接收和发送的能力。
2. 如果只有2次握手：万一服务端的应答在过程中丢失了，客户端不会和服务端进行连接，但是服务端会建立连接，这样会白白消耗资源。之后如果客户端再次重发请求，服务器就会认为这是两个TCP连接。

### 四次挥手🙋断开连接

假设是客户端主动要求关闭连接的。

1. 客户端进程发出一个报文，其中`FIN=1`。
2. 服务器接收到报文之后，发送一个确认报文。
3. 服务器发送未传输完的数据。
4. 服务器发送自己的终止报文，有`FIN=1`。
5. 服务器接收到之后对其进行确认，并定时等待一段时间之后关闭连接。
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk753ihbkj30sm0y8x6p.jpg" alt="image-20201110161653631" style="zoom: 33%;" />


- [x] 为何需要4次挥手？

1. 客户端发起关闭请求时，它的数据必然是已经发送完毕的。但是服务器的数据可能被发送完毕，所以需要等服务器发送完了之后才会再给一个`FIN=1`。

- [x] 为什么要定时等待？

1. 避免客户端发送的ACK没有到达服务端，这样服务端没有接收到ACK会重发FIN且不会释放资源。

### 总结一下
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkk75g9ni8j30uo0rsqv5.jpg" alt="image-20201110161905182" style="zoom:50%;" />


# 回到wireshark抓包

最后会到之前抓包的结果看一看。中括号内的是首部中的位。

| 包序号 | 方向          | 包内容                                                       |
| ------ | ------------------- | ------------------------------------------------------------ |
| 1      | 51171 ➡️  8090 | [SYN], Seq=0, Len=0                                          |
| 2      | 8090 ➡️  51171 | [SYN, ACK], Seq=0, Ack=1, Len=0                              |
| 3      | 51171 ➡️  8090 | [ACK], Seq=1, Ack=1, Len=0                                   |
| 4      |               |                                                              |
| 5      | 51171 ➡️  8090 | [PSH, ACK], Seq=1, Ack=1, Len=12（Data = hello world!）      |
| 6      | 8090 ➡️  51171 | [ACK], Seq=1, Ack=13, Len=0                                  |
| 7      | 8090 ➡️  51171 | [PSH, ACK], Seq=1, Ack=13, Len=22（Data = Get your: HELLO WORLD!） |
| 8      | 8090 ➡️  51171 | [FIN, ACK], Seq=23, Ack=13, Len=0                            |
| 9      | 51171 ➡️  8090 | [ACK], Seq=13, Ack=23, Len=0  |
| 10     | 51171 ➡️  8090 | [ACK], Seq=13, Ack=24, Len=0      |
| 11     | 51171 ➡️  8090 | [Fin, ACK], Seq=13, Ack=24, Len=0 |
| 12     | 8090 ➡️  51171 | [Ack], Seq=24, Ack=14, Len=0      |


> 包1中的`Seq`实际上是随机生成的数字`368303858`，但后面都用相对表示，所以直接认为=0；
>
> 包2中的`Ack`也是同理。

挥手流程梳理如下：

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkk76fn6b1j30o40e2gnu.jpg)



# 预告

篇幅比较长了，就先写到这里。我是一名正在自学计算机的大四学生，会在我的博客中记录我的学习之路，欢迎在《开发者头条》中订阅我的独家号「彬Goh的Coding之路」。一起进步吧！






